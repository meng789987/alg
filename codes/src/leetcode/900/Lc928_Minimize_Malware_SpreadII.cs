using System;
using System.Collections.Generic;
using System.Linq;

using alg;

/*
 * tags: disjoint set
 * Time(n^2), Space(n)
 * let G is the graph removed all malware nodes. 
 * if a disjoint set of nodes in G is infected by only one malware node, then that malware node is a candidate to remove.
 */
namespace leetcode
{
    public class Lc928_Minimize_Malware_SpreadII
    {
        public int MinMalwareSpread(int[][] graph, int[] initial)
        {
            int n = graph.Length;
            var hasMalwares = new bool[n];
            foreach (var v in initial)
                hasMalwares[v] = true;

            var ds = new DisjointSet(n);
            for (int i = 0; i < n; i++)
            {
                if (hasMalwares[i]) continue;
                for (int j = 0; j < n; j++)
                    if (!hasMalwares[j] && graph[i][j] == 1) ds.Union(i, j);
            }

            var malNodes = new HashSet<int>[n]; // connected count of disjoint set for each malware
            var counts = new int[n]; // connected count of malware for each node
            foreach (var v in initial)
            {
                malNodes[v] = new HashSet<int>();
                for (int j = 0; j < n; j++)
                    if (!hasMalwares[j] && graph[v][j] == 1)
                        malNodes[v].Add(ds.Find(j));

                foreach (var j in malNodes[v])
                    counts[j]++;
            }

            // score the disjoint set only if it is infected by one malware uniquely
            int res = 0, maxScore = -1;
            foreach (var v in initial)
            {
                int score = 0;
                foreach (var j in malNodes[v])
                    if (counts[j] == 1) score += ds.Size(j);

                if (maxScore < score || (maxScore == score && res > v))
                {
                    maxScore = score;
                    res = v;
                }
            }


            return res;
        }

        public void Test()
        {
            var graph = new int[][] { new int[] { 1, 1, 0 }, new int[] { 1, 1, 0 }, new int[] { 0, 0, 1 } };
            var initial = new int[] { 0, 1 };
            Console.WriteLine(MinMalwareSpread(graph, initial) == 0);

            graph = new int[][] { new int[] { 1, 1, 0 }, new int[] { 1, 1, 1 }, new int[] { 0, 1, 1 } };
            initial = new int[] { 0, 1 };
            Console.WriteLine(MinMalwareSpread(graph, initial) == 1);

            graph = new int[][] { new int[] { 1, 1, 0, 0 }, new int[] { 1, 1, 1, 0 }, new int[] { 0, 1, 1, 1 }, new int[] { 0, 0, 1, 1 } };
            initial = new int[] { 0, 1 };
            Console.WriteLine(MinMalwareSpread(graph, initial) == 1);
        }
    }
}

